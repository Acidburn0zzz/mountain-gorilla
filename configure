#!/bin/bash
# vi: tabstop=4 expandtab shiftwidth=4
#
# Configure the mountain gorilla (aka SDC) build.
#
# "targets.json" is a mapping of Makefile target to info about that target:
# - repos: A list of repos to clone to the "build/" directory for building it.
#   Each repo entry is an object like this:
#       {"url": "git@git.joyent.com:cloud-analytics.git",
#        "submodule-recursive": false,      # optional
#        "dir": "good-ole-ca"}              # optional
# - deps: A list of dependent targets.

if [ "$TRACE" != "" ]; then
    export PS4='${BASH_SOURCE}:${LINENO}: '
    set -o xtrace
fi
set -o errexit
set -o pipefail



#---- config, globals

BRANCH=master
TRY_BRANCH=

# These two are used for tracking which targets will be built in a
# provisioned zone (separate from the current zone).
USEZONE=
NOUSEZONE=

ROOT=$(pwd)
CACHE_DIR=${ROOT}/cache

# Username and password filled by `ensure_bits_credentials`.
BITS_USERNAME=
BITS_PASSWORD=
BITS_PROTO=https
BITS_HOST=stuff.joyent.us
BITS_BASE_PATH=/stuff/builds

# This is a HACK to figure out if we're in the bh1 lab (assume we are if
# the IP is 10.2.X.X) so that we can switch the stuff url to an IP because
# the URL doesn't work in the lab.
if [[ $(uname -s) == "SunOS" && \
      $(sysinfo -p | grep "Network_Interface.*IPv4_Address=" \
        | cut -d "'" -f2 | grep 10\.2\. | wc -l | tr -d ' ') -gt 0 ]]; then
    # Assume we're in the BH-1 lab.
    echo "# Looks like we're in the BH-1 lab."
    BITS_HOST=10.2.0.190
fi

CP_LINK_OPT=
if [[ $(uname -s) == "SunOS" ]]; then
    CP_LINK_OPT=--link
fi
CURL="curl --fail --connect-timeout 10 -s"



#---- internal support functions

function fatal {
    echo "$(basename $0): error: $1"
    exit 1
}

function errexit {
    [[ $1 -ne 0 ]] || exit 0
    fatal "error exit status $1 at line $2"
}

function ensure_bits_credentials {
    MG_CONFIG_PATH=~/.mg.json
    if [[ -z "$BITS_USERNAME" ]]; then
        BITS_USERNAME=$(cat $MG_CONFIG_PATH | $JSON bits_username)
    fi
    if [[ -z "$BITS_USERNAME" ]]; then
        fatal "Could not get 'bits_username' from '$MG_CONFIG_PATH'."
    fi
    if [[ -z "$BITS_PASSWORD" ]]; then
        BITS_PASSWORD=$(cat $MG_CONFIG_PATH | $JSON bits_password)
    fi
    if [[ -z "$BITS_PASSWORD" ]]; then
        fatal "Could not get 'bits_password' from '$MG_CONFIG_PATH'."
    fi
}

# Blow away the bits cache once per-day because don't want it to grow
# unbounded in size (esp. for the continuous-build system). An alternative
# would be to put a size limit on it.
function flush_bits_cache() {
    if [[ -f $CACHE_DIR/bits/created ]]; then
        local bits_cache_age=$((`date "+%s"` - `stat -c %X $CACHE_DIR/bits/created`))
        # One day in 86400. We use a bit more to avoid harmonics with
        # once-per-day builds.
        if [[ $bits_cache_age -gt 100000 ]]; then
            echo "# Bit cache '$CACHE_DIR/bits' is more than a day old. Blowing it away to be recreated."
            rm -rf $CACHE_DIR/bits
        fi
    fi
}

# Preload $CACHE_DIR/bits/ with the latest built and uploaded bits for
# the given target and branch.
#
# Usage:
#   preload_bits TARGET BRANCH TRY_BRANCH
# where:
#   TARGET is a string subdir of the https://stuff.joyent.com/stuff/builds
#       builds repo OR a full path to such a dir. This must be a URL dir
#       that serves Apache/Nginx-index-style directories.
#
# Example:
#   preload_bits smartlogin master ""
#   preload_bits http://download.joyent.com/pub/build/sdcnode master ""
#
function preload_bits() {
    local target=$1
    local branch=$2
    local try_branch=$3
    local target_base=$(basename $target)

    # Don't bork if this was already preloaded by another target.
    if [[ -d bits/$target_base ]]; then
        return;
    fi

    echo ""
    echo "# preload 'bits/$target_base'"

    ensure_bits_credentials

    local target_url
    local target_url_censor
    if [[ $(echo $target | cut -c 1-4) == "http" ]]; then
        target_url=$target
        if [[ "${target_url:(-1)}" != "/" ]]; then
            target_url=$target_url/
        fi
        target_url_censor=$target_url
    else
        local bits_url=$BITS_PROTO://$BITS_USERNAME:$BITS_PASSWORD@$BITS_HOST$BITS_BASE_PATH
        local bits_url_censor=$BITS_PROTO://$BITS_USERNAME:*password*@$BITS_HOST$BITS_BASE_PATH
        if [[ "${bits_url:(-1)}" != "/" ]]; then
            bits_url=$bits_url/
        fi
        if [[ "${bits_url_censor:(-1)}" != "/" ]]; then
            bits_url_censor=$bits_url_censor/
        fi
        target_url=$bits_url$target_base
        target_url_censor=$bits_url_censor$target_base
    fi
    local_cache_reldir=${target_url#*://}
    local_cache_reldir=${local_cache_reldir#*@}

    # Branch dir: try $try_branch, then $branch.
    local best_branch=$try_branch
    local latest_url=$target_url$try_branch-latest/
    if [[ -z "$best_branch" ||
          $($CURL -kI $latest_url | head -1 | awk '{print $2}') != "200" ]]; then
        best_branch=$branch
        latest_url=$target_url$branch-latest/
        if [[ $($CURL -kIS $latest_url | head -1 | awk '{print $2}') != "200" ]]; then
            fatal "'$target_url_censor/$branch-latest/' does not exist"
        fi
    fi
    echo "# use branch '$best_branch'"

    # Find the latest build time for this branch.
    local latest_build=$($CURL -Sk $target_url \
        | grep "href=\"" \
        | cut -d'"' -f2 \
        | grep "^$best_branch-" \
        | grep -v -- '-latest/$' \
        | sort \
        | tail -1)
    local local_cache_dir=$CACHE_DIR/bits/$local_cache_reldir$latest_build$target_base

    if [[ -d $local_cache_dir ]]; then
        echo "# local cache at '$local_cache_dir' already exists"
    else
        # Mark creation for bits cache flush every day.
        mkdir -p $CACHE_DIR/bits
        if [[ ! -f $CACHE_DIR/bits/created ]]; then
            touch $CACHE_DIR/bits/created
        fi

        latest_url=$target_url$latest_build
        local latest_url_censor=$target_url_censor$latest_build

        # Update cache in $CACHE_DIR/bits
        # `-l 2`: Two levels deep needed for 2-level depth of 'agents' bits area.
        echo "# download from $latest_url_censor"
        (cd $CACHE_DIR/bits \
            && wget -q -np -l 2 --no-check-certificate -r -L -R 'index.html,*.log' \
                $latest_url$target_base/)
    fi
    local md5sums_path=$local_cache_dir/../md5sums.txt
    if [[ ! -f $md5sums_path ]]; then
        $CURL -Sk ${latest_url}md5sums.txt -o $md5sums_path
    fi

    # MD5 check of downloaded bits.
    for bit in $(cd $local_cache_dir/../ && find . -type f | grep -v md5sums.txt); do
        local correct_md5=$(grep $bit $md5sums_path | cut -d ' ' -f1)
        local actual_md5=$(openssl dgst -md5 < $local_cache_dir/../$bit | awk '{print $NF}')
        if [[ $correct_md5 != $actual_md5 ]]; then
            rm $local_cache_dir/../$bit
            fatal "md5 check failure on $local_cache_dir/../$bit (actual '$actual_md5', from md5sums '$correct_md5')"
        fi
    done

    # Copy over to bits dir.
    mkdir -p bits
    [[ -d "bits/$target_base" ]] && fatal "'bits/$target_base' already exists"
    cp -PR $CP_LINK_OPT $local_cache_dir bits/$target_base
}


#
# The requested target may use the new functionality to build it inside of an
# SDC zone. We check that here and note it for later use. We need to see whether
# use zone is set for the specified branch.
#
# Based on targets.json, we have three specific states. Something is entirely in
# the old world, in which case, neither USEZONE or NOUSEZONE get set. If the
# usezone value is there, then we need to check which it is so we can properly
# emit the right Makefile target snippet.
#
function check_usezone() {
	local zone use
	local target=$1

	zone=$($JSON $target < targets.json)
	[[ $? -eq 0 ]] || fatal "failed to read targets.json"
	use=$(echo $zone | $JSON usezone)
	if [[ -n "$use" ]]; then
		if [[ "$use" == "true" ]]; then
			USEZONE="$target $USEZONE"
		else
			NOUSEZONE="$target $NOUSEZONE"
		fi
	fi
}

# Clone/update the given git repo in the repo cache.
# Usage:
#   get_repo_cache REPO-URL REPO-DIR SUBMODULE-RECURSIVE
# Example:
#   get_repo_cache git@git.joyent.com:smart-login.git smart-login true
function get_repo_cache() {
    local repo_url=$1
    local repo_dir=$2
    local dst_dir=$CACHE_DIR/repos/$repo_dir

    if [[ ! -d "$CACHE_DIR/repos/$repo_dir" ]]; then
        mkdir -p $CACHE_DIR/repos
        local tmp_dir=$CACHE_DIR/repos/.tmp.$repo_dir
        rm -rf $tmp_dir
        git clone $repo_url $tmp_dir
        mv $tmp_dir $CACHE_DIR/repos/$repo_dir
    else
        (cd $CACHE_DIR/repos/$repo_dir; git pull)
    fi
    if [[ "$submodule_recursive" == "true" ]]; then
        (cd $CACHE_DIR/repos/$repo_dir; git submodule update --init --recursive)
    else
        (cd $CACHE_DIR/repos/$repo_dir; git submodule update --init)
    fi

    # Error out if the cached repo is dirty. These thigns should always
    # be pristine.
    if [[ "$(cd $CACHE_DIR/repos/$repo_dir && git describe --all --dirty | grep dirty)" != "" ]]; then
        fatal "Repo '$repo_dir' cache, $CACHE_DIR/repos/$repo_dir, is dirty!"
    fi
}


# Get the requested repo.
# Usage:
#   get_repo2 REPO-URL BRANCH SUBMODULE-RECURSIVE [NAME] [TRY-BRANCH]
#
# If "SUBMODULE-RECURSIVE" is "true", then "--recursive" is used on
# on the "git submodule update ..." call.
#
# If "NAME" is given, that subdir under "build/" will be used as the
# clone dir. Else it is inferred from the REPO-URL.
#
function get_repo2() {
    local repo_url=$1
    local branch=$2
    local submodule_recursive=$3
    local repo_dir=$4
    local try_branch=$5

    if [[ -z "$repo_dir" ]]; then
        repo_dir=${repo_url##*/}    # strip to last '/'
        repo_dir=${repo_dir##*:}    # strip to last ':'
        repo_dir=${repo_dir%*.git}    # strip '.git' at tail
    fi

    echo "# get '$repo_url' to repo cache ($CACHE_DIR/repos)"
    get_repo_cache ${repo_url} ${repo_dir} ${submodule_recursive}

    echo "# copy '$CACHE_DIR/repos/$repo_dir' to 'build/$repo_dir'"
    mkdir -p build
    cp -PR $CACHE_DIR/repos/$repo_dir build/$repo_dir
    (cd build/$repo_dir ; git checkout $branch)

    if [[ ! -z "$try_branch" ]]; then
        (cd build/$repo_dir ; git checkout $try_branch && git pull || true)
    fi
    if [[ "$submodule_recursive" == "true" ]]; then
        (cd build/$repo_dir; git submodule update --init --recursive)
    else
        (cd build/$repo_dir; git submodule update --init)
    fi
}

function gen_config() {
    local output
    mkdir -p bits
    cat <<EOF >bits/config.mk
TIMESTAMP=$(TZ=UTC date "+%Y%m%dT%H%M%SZ")
BRANCH=$BRANCH
TRY_BRANCH=$TRY_BRANCH
MG_NODE=$MG_NODE

EOF
  mkdir -p build
  cd build/
  for repo in $(ls -1) ; do
      upper_repo_name=$(echo $repo | tr [:lower:] [:upper:] | tr - _)
      if [[ $(cat ${ROOT}/targets.json | $JSON ${repo} | $JSON appliance) == 'true' ]]; then
        echo ${upper_repo_name}_DATASET=$(cat ${ROOT}/targets.json | json ${repo}.dataset_uuid) >> ${ROOT}/bits/config.mk
        echo ${upper_repo_name}_PKGSRC=\"$(cat ${ROOT}/targets.json | json ${repo}.pkgsrc | json -a |  xargs)\" >> ${ROOT}/bits/config.mk
        echo ${upper_repo_name}_URN=\"$(cat ${ROOT}/targets.json | json ${repo}.urn)\" >> ${ROOT}/bits/config.mk
        echo ${upper_repo_name}_VERSION=\"$(cat ${ROOT}/targets.json | json ${repo}.version)\" >> ${ROOT}/bits/config.mk
        deps=""
        for dep in $(cat ${ROOT}/targets.json | json ${repo}.deps | json -a |  xargs); do
          if [[ -n $TARGET ]]; then
            deps="${deps} $(ls ${ROOT}/bits/${dep}/*.tar.* | xargs)"
          else
            deps="${deps} \$($(echo $dep | tr [:lower:] [:upper:])_BITS)"
          fi
        done
        if [[ -n ${deps} ]]; then
          echo ${upper_repo_name}_EXTRA_TARBALLS=\"${deps}\" >> ${ROOT}/bits/config.mk
        fi
      fi
      branch_name=$((cd ${repo} && git symbolic-ref HEAD 2> /dev/null ) || echo "")
      echo ${upper_repo_name}_BRANCH=$(echo ${branch_name##refs/heads/} || echo "") >> ${ROOT}/bits/config.mk
      echo ${upper_repo_name}_SHA=$((cd ${repo} && git log --pretty=format:'%h' -1 ) || echo "") >> ${ROOT}/bits/config.mk
  done

  touch ${ROOT}/bits/config.targ.mk

  for targ in $USEZONE; do
      output="\$($(echo $targ | tr [:lower:] [:upper:])_BITS): config_${targ}_new"
      echo $output >> ${ROOT}/bits/config.targ.mk
  done

  for targ in $NOUSEZONE; do
      output="\$($(echo $targ | tr [:lower:] [:upper:])_BITS): config_${targ}_old"
      echo $output >> ${ROOT}/bits/config.targ.mk
  done
}


function print_help() {
    echo "Configure this SDC build. This involves cloning/pulling the "
    echo "component source repositories."
    echo ""
    echo "Usage:"
    echo "  ./configure [OPTIONS]"
    echo ""
    echo "Options:"
    echo "  -h, --help   Print this help and exit."
    echo ""
    echo "  -n NODE_EXE  Path to node exe for MG to use."
    echo ""
    echo "  -b BRANCH    Branch to checkout. Defaults to 'master'."
    echo "               Note that this is for *all* core repositories."
    echo "  -B TRY-BRANCH"
    echo "               Branch to try to checkout (if it exists). '-b' value"
    echo "               is used as the default. This is useful for building"
    echo "               a feature branch on one of the many repos used for"
    echo "               a target."
    echo "  -t TARGET    Prepare to build only this target. Valid targets are"
    echo "               the keys of 'targets.json' plus a special value"
    echo "               'all-except-platform' to build all targets except the"
    echo "               slow-to-build platform."
    echo "  -r           Regenerate config.mk. This doesn't touch repos in"
    echo "               'build/' or preload in 'bits/'."
    echo "  -c CACHE_DIR Specify a cache directory. Default: './cache'."
    echo "               The cache is used for caching git clones and"
    echo "               preloaded bits. The 'bits cache' is automatically"
    echo "               removed if it is more than a day old."
    exit 0
}


function get_target_repos() {
    local target=$1
    local info
    for info in `cat targets.json | $JSON $target.repos | $JSON -a -d, url dir submodule-recursive`; do
        local repo_url=$(echo "$info" | cut -d, -f 1)
        local repo_dir=$(echo "$info" | cut -d, -f 2)
        local submodule_recursive=$(echo "$info" | cut -d, -f 3)
        [[ -z "$submodule_recursive" ]] && submodule_recursive=true
        get_repo2 $repo_url $BRANCH "$submodule_recursive" "$repo_dir" "$TRY_BRANCH"
    done
}

function get_pkgsrc() {
  if [[ -d ${ROOT}/build/usb-headnode ]]; then
    echo "# get pkgsrc packages for build/usb-headnode zones (to build/pkgsrc)"

    mkdir -p build/pkgsrc/

    for dataset in $(find ${ROOT}/build/usb-headnode/zones -name "dataset"); do
      local ds=$(cat ${dataset})
      local pkgsrc_url=$((${JSON} datasets | ${JSON} -a name pkgsrc_url \
          | grep "$(basename ${ds})" \
          | cut -d ' ' -f2) < ${ROOT}/build/usb-headnode/build.spec)
      if [[ ${pkgsrc_url:(-1)} != "/" ]]; then
        pkgsrc_url=$pkgsrc_url/
      fi
      local pkgsrc_ver=$(echo "${pkgsrc_url}" | cut -d '/' -f5)
      local gccver=$(echo "${pkgsrc_url}" | cut -d '/' -f6)

      local cache_dir=$CACHE_DIR/pkgsrc/$pkgsrc_ver/$gccver/All
      local dest_dir=build/pkgsrc/${pkgsrc_ver}/${gccver}/All
      mkdir -p $cache_dir
      mkdir -p $dest_dir

      if [[ ! -f $dest_dir/md5sums.txt ]]; then
          echo "# get ${pkgsrc_url}md5sums.txt"
          ${CURL} -S -o $cache_dir/md5sums.txt ${pkgsrc_url}md5sums.txt
          cp $CP_LINK_OPT $cache_dir/md5sums.txt $dest_dir/md5sums.txt
      fi

      for file in $(cat $(dirname ${dataset})/pkgsrc); do
        if [[ -f $dest_dir/$file.tgz ]]; then
            true # pass through
        else
            if [[ ! -f $cache_dir/${file}.tgz ]]; then
              echo "# get ${pkgsrc_url}${file}.tgz"
              ${CURL} -S -o $cache_dir/$file.tgz ${pkgsrc_url}/${file}.tgz
              local correct_md5=$(grep $file $cache_dir/md5sums.txt | cut -d ' ' -f1)
              local actual_md5=$(openssl dgst -md5 < $cache_dir/$file.tgz | awk '{print $NF}')
              if [[ $correct_md5 != $actual_md5 ]]; then
                  rm $cache_dir/$file.tgz
                  fatal "md5 check failure on $cache_dir/$file.tgz (actual $actual_md5, from md5sums $correct_md5)"
              fi
            else
                echo "# have $cache_dir/$file.tgz"
            fi
            cp $CP_LINK_OPT $cache_dir/$file.tgz $dest_dir/
        fi
      done
    done
  fi
}




#---- mainline

trap 'errexit $? $LINENO' EXIT

# Can be a target name to tell 'configure' to (a) limit prep to just that
# target and (b) pre-load "bits/" with pre-built dependent target bits.
# If empty it means that we are configuring for a full build.
TARGET=
REGENERATE='false'
MG_NODE=$(which node)


if [[ "$1" == "--help" ]]; then
  print_help
fi
while getopts "b:B:hrft:c:n:" opt; do
    case "$opt" in
        b) BRANCH=$OPTARG ;;
        B) TRY_BRANCH=$OPTARG ;;
        h) print_help ;;
        r)
            REGENERATE='true'
            ;;
        n) MG_NODE=${OPTARG} ;;
        t) TARGET=${OPTARG} ;;
        c) CACHE_DIR=${OPTARG} ;;
        ?) fatal "unknown option: $opt" ;;
    esac
done
shift $((OPTIND-1))


# Pre-condition: must have node >=0.6 first on path (see RELENG-266).
echo "Ensure have a 'node' v0.6."
NODE_VERSION=$($MG_NODE --version)
NODE_VERSION=${NODE_VERSION:0:4}
if [[ "$NODE_VERSION" != "v0.6" ]]; then
    fatal "Incorrect node version, '${NODE_VERSION}'. MG needs a node v0.6 or later (currently requiring v0.6). Either put a node v0.6 first on your PATH or use the '-n NODE_EXE' configure option."
fi
JSON="$MG_NODE $ROOT/tools/json"

# '-r' regenerate early out.
if [[ "$REGENERATE" == 'true' ]]; then
    gen_config
    exit 0
fi


# Else we are doing a full configure for a fresh build. Start fresh:
mkdir -p bits
touch bits/config.mk
touch bits/config.targ.mk
make distclean


if [[ ! -z "$TARGET" ]]; then
    flush_bits_cache
    if [[ "$TARGET" == "all-except-platform" ]]; then
        preload_bits "platform" "$BRANCH" "$TRY_BRANCH"
        targets=$(${MG_NODE} -e 'fs=require("fs"); c=fs.readFileSync("targets.json"); console.log(Object.keys(JSON.parse(c)).join("\n"))' | grep -v '^platform' | grep -v '^illumosextra')
        for targ in $targets; do
            check_usezone $targ
            get_target_repos $targ
        done
    else
        # Validate target.
        if [[ -z "$(cat targets.json | $JSON $TARGET)" ]]; then
            fatal "Unknown target: $TARGET"
        fi
        check_usezone $TARGET
        get_target_repos $TARGET
        for dep in `cat targets.json | $JSON $TARGET.deps | $JSON -a`; do
            preload_bits $dep "$BRANCH" "$TRY_BRANCH"
        done
    fi
else
    targets=$(${MG_NODE} -e 'fs=require("fs"); c=fs.readFileSync("targets.json"); console.log(Object.keys(JSON.parse(c)).join("\n"))')
    for targ in $targets; do
        check_usezone $targ
        get_target_repos $targ
    done
fi

# "all" is a special target with deps to always preload.
# I.e. for which "make all" doesn't build it.
for dep in `cat targets.json | $JSON all.deps | $JSON -a`; do
    preload_bits $dep "$BRANCH" "$TRY_BRANCH"
done

get_pkgsrc

gen_config

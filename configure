#!/bin/bash
# vi: tabstop=4 expandtab shiftwidth=4
#
# Configure the mountain gorilla (aka SDC) build.
#
# "targets.json" is a mapping of Makefile target to info about that target:
# - repos: A list of repos to clone to the "build/" directory for building it.
#   Each repo entry is an object like this:
#       {"url": "git@git.joyent.com:cloud-analytics.git",
#        "submodule-recursive": false,      # optional
#        "dir": "good-ole-ca"}              # optional
# - deps: A list of dependent targets.

if [ "$TRACE" != "" ]; then
    export PS4='${BASH_SOURCE}:${LINENO}: '
    set -o xtrace
fi
set -o errexit
set -o pipefail



#---- config, globals

BRANCH=master
TRY_BRANCH=

ROOT=$(pwd)
if [ "$CACHE_DIR" != "" ]; then
    CACHE_DIR=${ROOT}/cache
fi

JSON=$ROOT/tools/json



#---- internal support functions

function fatal {
    echo "$(basename $0): error: $1"
    exit 1
}

function errexit {
    [[ $1 -ne 0 ]] || exit 0
    fatal "error exit status $1 at line $2"
}

# Preload bits/ with the latest built and uploaded bits for
# the given target and branch.
# Usage:
#   preload_bits TARGET BRANCH TRY_BRANCH
#
function preload_bits() {
    local target=$1
    local branch=$2
    local try_branch=$3

    echo "# preload bits/$target from stuff.joyent.us/builds/$target/$branch-latest/$target"
    local ssh="ssh -q -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null"
    mkdir -p bits/$target
    if [[ ! -z "$try_branch" ]]; then
        local out=$($ssh stuff@stuff.joyent.us ls -d builds/$target/$try_branch-latest/$target 2>&1 || true)
        if [[ "${out##*: }" != "No such file or directory" ]]; then
            rsync -e "$ssh" -av \
                stuff@stuff.joyent.us:builds/$target/$try_branch-latest/$target/ \
                bits/$target/
            return
        fi
    fi
    rsync -e "$ssh" -av \
        stuff@stuff.joyent.us:builds/$target/$branch-latest/$target/ \
        bits/$target/
}


# Clone/update the given git repo in the repo cache.
# Usage:
#   get_repo_cache REPO-URL REPO-DIR SUBMODULE-RECURSIVE
# Example:
#   get_repo_cache git@git.joyent.com:smart-login.git smart-login true
function get_repo_cache() {
    local repo_url=$1
    local repo_dir=$2
    local dst_dir=$CACHE_DIR/repos/$repo_dir

    if [[ ! -d "$CACHE_DIR/repos/$repo_dir" ]]; then
        mkdir -p $CACHE_DIR/repos
        local tmp_dir=$CACHE_DIR/repos/.tmp.$repo_dir
        rm -rf $tmp_dir
        git clone $repo_url $tmp_dir
        mv $tmp_dir $CACHE_DIR/repos/$repo_dir
    else
        (cd $CACHE_DIR/repos/$repo_dir; git pull)
    fi
    if [[ "$submodule_recursive" == "true" ]]; then
        (cd $CACHE_DIR/repos/$repo_dir; git submodule update --init --recursive)
    else
        (cd $CACHE_DIR/repos/$repo_dir; git submodule update --init)
    fi
}


# Get the requested repo.
# Usage:
#   get_repo2 REPO-URL BRANCH SUBMODULE-RECURSIVE [NAME] [TRY-BRANCH]
#
# If "SUBMODULE-RECURSIVE" is "true", then "--recursive" is used on
# on the "git submodule update ..." call.
#
# If "NAME" is given, that subdir under "build/" will be used as the
# clone dir. Else it is inferred from the REPO-URL.
#
function get_repo2() {
    local repo_url=$1
    local branch=$2
    local submodule_recursive=$3
    local repo_dir=$4
    local try_branch=$5

    if [[ -z "$repo_dir" ]]; then
        repo_dir=${repo_url##*/}    # strip to last '/'
        repo_dir=${repo_dir##*:}    # strip to last ':'
        repo_dir=${repo_dir%*.git}    # strip '.git' at tail
    fi

    echo "# get '$repo_url' to repo cache ($CACHE_DIR/repos)"
    get_repo_cache ${repo_url} ${repo_dir} ${submodule_recursive}

    echo "# copy '$CACHE_DIR/repos/$repo_dir' to 'build/$repo_dir'"
    mkdir -p build
    cp -PR $CACHE_DIR/repos/$repo_dir build/$repo_dir
    (cd build/$repo_dir ; git checkout $branch)

    if [[ ! -z "$try_branch" ]]; then
        (cd build/$repo_dir ; git checkout $try_branch && git pull || true)
    fi
    if [[ "$submodule_recursive" == "true" ]]; then
        (cd build/$repo_dir; git submodule update --init --recursive)
    else
        (cd build/$repo_dir; git submodule update --init)
    fi
}

function gen_config() {
    mkdir -p bits
    cat <<EOF >bits/config.mk
TIMESTAMP=$(TZ=UTC date "+%Y%m%dT%H%M%SZ")
BRANCH=$BRANCH
TRY_BRANCH=$TRY_BRANCH
EOF
  cd build/
  for repo in * ; do
      upper_repo_name=$(echo $repo | tr [:lower:] [:upper:] | tr - _)
      branch_name=$((cd ${repo} && git symbolic-ref HEAD 2> /dev/null ) || echo "")
      echo ${upper_repo_name}_BRANCH=$(echo ${branch_name##refs/heads/} || echo "") >> ${ROOT}/bits/config.mk
      echo ${upper_repo_name}_SHA=$((cd ${repo} && git log --pretty=format:'%h' -1 ) || echo "") >> ${ROOT}/bits/config.mk
  done
}

function gen_config_old() {
    mkdir -p bits
    cat <<EOF >bits/config.mk
TIMESTAMP=$(TZ=UTC date "+%Y%m%dT%H%M%SZ")
BRANCH=$BRANCH
TRY_BRANCH=$TRY_BRANCH
EOF

  targets=$(node -e 'fs=require("fs"); c=fs.readFileSync("targets.json"); Object.keys(JSON.parse(c)).join(" ")')
  for target in $targets; do
      repo_url=$(cat targets.json | json ${target}.repos.0.url)
      repo_dir=${repo_url##*/}    # strip to last '/'
      repo_dir=${repo_dir##*:}    # strip to last ':'
      repo_dir=${repo_dir%*.git}    # strip '.git' at tail
      if [[ -d build/${repo_dir} ]]; then
        upper_targ_name=$(echo $target | tr [:lower:] [:upper:] | tr - _)
        branch_name=$((cd build/${repo_dir} && git symbolic-ref HEAD 2> /dev/null ) || echo "")
        echo ${upper_targ_name}_BRANCH=$(echo ${branch_name##refs/heads/} || echo "") >> bits/config.mk
        echo ${upper_targ_name}_SHA=$((cd build/${repo_dir} && git log --pretty=format:'%h' -1 ) || echo "") >> bits/config.mk
      fi
  done
}


function print_help() {
    echo "Configure this SDC build. This involves cloning/pulling the "
    echo "component source repositories."
    echo ""
    echo "Usage:"
    echo "  ./configure [ -b BRANCH ] [ -r REPO [-f] ] [ -t TARGET ]"
    echo ""
    echo "Options:"
    echo "  -h, --help   Print this help and exit."
    echo "  -b BRANCH    Branch to checkout. Defaults to 'master'."
    echo "               Note that this is for *all* core repositories."
    echo "  -B TRY-BRANCH"
    echo "               Branch to try to checkout (if it exists). '-b' value"
    echo "               is used as the default. This is useful for building"
    echo "               a feature branch on one of the many repos used for"
    echo "               a target."
    echo "  -t TARGET    Prepare to build only this target."
    echo "  -r           Regenerate config.mk. This doesn't touch repos in"
    echo "               'build/' or preload in 'bits/'."
    echo "  -c CACHE_DIR Specify a cache directory. Default: './cache'."
    exit 0
}


function get_target_repos() {
    local target=$1
    local info
    for info in `cat targets.json | $JSON $target.repos | $JSON -a -d, url dir submodule-recursive`; do
        local repo_url=$(echo "$info" | cut -d, -f 1)
        local repo_dir=$(echo "$info" | cut -d, -f 2)
        local submodule_recursive=$(echo "$info" | cut -d, -f 3)
        [[ -z "$submodule_recursive" ]] && submodule_recursive=true
        get_repo2 $repo_url $BRANCH "$submodule_recursive" "$repo_dir" "$TRY_BRANCH"
    done
}

function get_pkgsrc() {
  if [[ -d ${ROOT}/build/usb-headnode ]]; then
    echo "# get pkgsrc packages for usb-headnode zones (to build/pkgsrc)"

    mkdir -p build/pkgsrc/
    local curl_opts="--fail --connect-timeout 10 --silent"

    for sourcefile in $(find ${ROOT}/build/usb-headnode/zones | grep "pkgsrc"); do
      pkgsrc_ver=$(basename ${sourcefile} | cut -d "_" -f2)
      pkgsrc_64bit=$(basename ${sourcefile} | grep "_64" || echo "")

      if [[ -n ${pkgsrc_64bit} ]]; then
        gccver="gcc45-64"
      else
        gccver="gcc45"
      fi

      mkdir -p build/pkgsrc/${pkgsrc_ver}/${gccver}/All

      if [[ ! -f build/pkgsrc/${pkgsrc_ver}/${gccver}/All/md5sums.txt ]]; then
        echo "# get http://pkgsrc.joyent.com/sdc6/${pkgsrc_ver}/${gccver}/All/md5sums.txt"
        curl ${curl_opts} -o build/pkgsrc/${pkgsrc_ver}/${gccver}/All/md5sums.txt \
            http://pkgsrc.joyent.com/sdc6/${pkgsrc_ver}/${gccver}/All/md5sums.txt
      fi

      for file in $(cat ${sourcefile}); do
        if [[ ! -f build/pkgsrc/${pkgsrc_ver}/${gccver}/All/${file}.tgz ]]; then
            echo "# get http://pkgsrc.joyent.com/sdc6/${pkgsrc_ver}/${gccver}/All/${file}.tgz"
            (cd build/pkgsrc/${pkgsrc_ver}/${gccver}/All && \
              curl ${curl_opts} -O http://pkgsrc.joyent.com/sdc6/${pkgsrc_ver}/${gccver}/All/${file}.tgz)
        fi
      done
    done

    #TODO: md5sum check against md5sums.txt
    #TODO: move to cache/pkgsrc ?
  fi
}




#---- mainline

trap 'errexit $? $LINENO' EXIT

# Can be a target name to tell 'configure' to (a) limit prep to just that
# target and (b) pre-load "bits/" with pre-built dependent target bits.
# If empty it means that we are configuring for a full build.
TARGET=
REGENERATE='false'

if [[ "$1" == "--help" ]]; then
  print_help
fi
while getopts "b:B:hurft:c:" opt; do
    case "$opt" in
        b) BRANCH=$OPTARG ;;
        B) TRY_BRANCH=$OPTARG ;;
        h) print_help ;;
        r)
            REGENERATE='true'
            ;;
        t) TARGET=${OPTARG} ;;
        c) CACHE_DIR=${OPTARG} ;;
        ?) fatal "unknown option: $opt" ;;
    esac
done
shift $((OPTIND-1))

# Pre-condition: some required binaries
binaries="/opt/node/0.4/bin/node /opt/node/0.6/bin/node /opt/node/0.6.9/bin/node /opt/npm/1.0/bin/npm /opt/npm/1.1/bin/npm"
for binary in $binaries; do
    if [[ ! -x $binary ]]; then
        fatal "Could not find required binary: '$binary'"
    fi
done

# Pre-condition: must have node >=0.6 first on path (see RELENG-266).
NODE_VERSION=$(node --version)
NODE_VERSION=${NODE_VERSION:0:4}
if [[ "$NODE_VERSION" != "v0.6" ]]; then
    fatal "Incorrect node version, '${NODE_VERSION}'. First node on PATH must be v0.6."
fi


# '-r' regenerate early out.
if [[ "$REGENERATE" == 'true' ]]; then
    gen_config
    exit 0
fi


# Else we are doing a full configure for a fresh build. Start fresh:
mkdir -p bits
touch bits/config.mk
make distclean


if [[ ! -z "$TARGET" ]]; then
    get_target_repos $TARGET
    for targ in `cat targets.json | $JSON $TARGET.deps | $JSON -a`; do
        preload_bits $targ "$BRANCH" "$TRY_BRANCH"
    done
else
    targets=$(node -e 'fs=require("fs"); c=fs.readFileSync("targets.json"); console.log(Object.keys(JSON.parse(c)).join("\n"))')
    for targ in $targets; do
        get_target_repos $targ
    done
fi

get_pkgsrc

gen_config
